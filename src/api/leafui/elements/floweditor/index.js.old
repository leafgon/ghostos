/**
 * Copyright (c) 2019-present, LEA Ltd
 */
import React, { useState, useEffect, useRef, MouseEvent } from 'react';
import { ChangeEvent } from 'react';

import ReactFlow, {
  ReactFlowProvider,
  isEdge,
  removeElements,
  addEdge,
  MiniMap,
  Controls,
  Node,
  FlowElement,
  OnLoadParams,
  Elements,
  Position,
  SnapGrid,
  Connection,
  Edge,
  isNode,
} from 'react-flow-renderer';

import {v4 as uuidv4} from 'uuid';

import {LEAFUtilityNode, LEAFOperatorNode, LEAFDataFilterNode, LEAFDataCombineNode, LEAFNodeContextNode, LEAFEdgeContextNode, LEAFAnchorPointNode, LEAFDeckSpade, LEAFDeckDiamond, LEAFDeckHeart, LEAFDeckClub, LEAFDeckTracker} from './leafnodes';
import {LEAFEdge, LEAFLambdaEdge, LEAFAnchorEdge} from './leafedge';
import LEAFSidebar from './sidebar';
import GRAPHQL_CLIENT from './GraphQLSetup';

import { ClientContext } from 'graphql-hooks'
import { useSubscription, useMutation } from 'graphql-hooks';

import dagre from 'dagre';
//import SHA256 from 'crypto-js/sha256';
//import Base64 from 'crypto-js/enc-base64';
//import { base64 } from 'sjcl/core/codecBase64';
//import { sha256 } from 'sjcl/core/sha256'
//import sjcl from 'sjcl';

import {mutateUpdateNode, mutateAddNode, mutateDelNode, mutateAddEdge, mutateDelEdge, getLEAFgqlSubs, getLEAFgqlStrAddNode, getLEAFgqlStrUpdateNode, getLEAFgqlStrDelNode, MUT_UPDATENODE, MUT_ADDNODE, MUT_DELNODE} from './leafgql';
import { isNullableType } from 'graphql';

import createClient from '../../lib/graphql/client';
import { endpoint_subs, websocket_subs, endpoint_qm } from './leafgql';

const dagreGraph = new dagre.graphlib.Graph();
dagreGraph.setDefaultEdgeLabel(() => ({}));

const LEAFEditorCore = (props) => {
  const initBgColor = '#6f6e77';

  const connectionLineStyle = { stroke: '#fff' };
  const snapGrid = [16, 16];
  const nodeTypes = {
    leafutilitynode: LEAFUtilityNode,
    leafoperatornode: LEAFOperatorNode,
    leafdatafilternode: LEAFDataFilterNode,
    leafdatacombinenode: LEAFDataCombineNode,
    leafnodecontextnode: LEAFNodeContextNode,
    leafedgecontextnode: LEAFEdgeContextNode,
    leafanchorpointnode: LEAFAnchorPointNode,
    leafdeckspade: LEAFDeckSpade,
    leafdeckdiamond: LEAFDeckDiamond,
    leafdeckheart: LEAFDeckHeart,
    leafdeckclub: LEAFDeckClub,
    leafdecktracker: LEAFDeckTracker,
  };

  const edgeTypes = {
    leafdataedge: LEAFEdge,
    leaflambdaedge: LEAFLambdaEdge,
    leafanchoredge: LEAFAnchorEdge,
  };


  const [elements, setElements] = useState([]);
  const [bgColor, setBgColor] = useState(initBgColor);
  const [isSelectable, setIsSelectable] = useState(true);
  const [reactFlowInstance, setReactFlowInstance] = useState(null);
  //const [isDraggable, setIsDraggable] = useState(false);
  //const [isConnectable, setIsConnectable] = useState(false);
  const reactFlowWrapper = useRef(null);

  //const mutationRequests = useRef([]); // a buffer of LEAFgql mutation strings to be processed
  //const [mutateUpdateNode] = useMutation(MUT_UPDATENODE, {fetchOptionsOverrides: { method: 'POST', mode: 'no-cors' }});
  //const [mutateAddNode] = useMutation(MUT_ADDNODE, {fetchOptionsOverrides: { method: 'POST' }});

  //const nfilter = '{in_edges: {label: {eq: "Alice39-ala2"}}}'
  //const appid2 = SHA256('www.leafgon.com').toString();
  //const appid = Base64.stringify(SHA256('www.leafgon.com'));
  //const appid = Base64.stringify(SHA256('temporary_test_appid'));
  //const appid = sjcl.codec.base64.fromBits(sjcl.hash.sha256.hash('temporary_test_appid'));
  //const nfilter = `{appid: {eq: "${appid}"}}`
  //const efilter = `{appid: {eq: "${appid}"}}`
  const nfilter = '{}';
  const efilter = '{}';
  const SUBS_GRAPH = `
    subscription {
      getGraph(nfilter: ${nfilter}, efilter: ${efilter}) {
        nodes {
          appid
          userid
          uuid
          label
          out_edges {uuid label source {uuid label} target {uuid label}}
          in_edges {uuid label source {uuid label} target {uuid label}}
          data
        }
      }
    }
  `;

  const a_new_node = '';
  const MUT_AddNode = `
    mutation {
      addNode(input: [${a_new_node}]) {node {label}}
    }
  `;
  const MUT_DelNode = `
    mutation {
      deleteNode(nfilter: {leaduuid: {eq: }})
    }
  `;
  const MUT_AddEdge = ``;
  const MUT_DelEdge = ``;

  const gql_qm_client = createClient({
    endpoint: endpoint_qm,
    headers: {
      //'Content-Type': 'application/json', // should never use this when using fetch
      'Accept': 'application/json'
    }
  });

  /*
  {
    id: 'bc3',
    type: 'leafdatafilternode',
    data: { onChange: onTextChange, leaduuid: 'bc3' },
    style: { border: '1px solid #777', padding: 2, borderRadius: '5px' },
    //position: { x: 250, y: 50 },
  }
  { id: 'bc_e3', source: 'bc1', target: '2', sourceHandle: 'out_aux', targetHandle: 'in_aux', type: 'leaflambdaedge', animated: false, style: {stroke: '#8ff', fillOpacity: 0 , }, data: { text: 'e1-2' } },
  */

  //useSubscription(
  //  {
  //    query: getLEAFgqlSubs('temporary_test_appid')
  //  },
  //  handleGraphUpdate
  //);

  /*
  const gql_subs_client = createClient({
    endpoint: endpoint_subs,
    headers: {
      'Content-Type': 'application/json',
    },
    websocket: {
      endpoint: websocket_subs,
      onConnectionSuccess: () => console.log('gql_subs_client: Connected'),
      onConnectionError: () => console.log('gql_subs_client: Connection Error'),
    }
  });

  const subsCallback = (event) => {
    console.log(event);
  };
  const errorSubsCallback = (error) => {
    console.log('Error: ', error);
  };
  try {
    gql_subs_client.subscribe(
      {
        subscription: getLEAFgqlSubs('temporary_test_appid'),
      },
      subsCallback,
      errorSubsCallback
    );
  } catch (error) {
    console.log('Error: ', error);
  }
  */
  //let muts = mutationRequests.current.shift(); // remove the first item of the array
  //while (muts) {
  //  mutateNode();
  //  muts = mutationRequests.current.shift(); // remove the next item of the array if any
  //}

  const randNames = {"data":["Park", "Lim", "Koob", "Oh", "Cho", "Smith","Johnson","Williams","Brown","Jones","Miller","Davis","Garcia","Rodriguez","Wilson","Martinez","Anderson","Taylor","Thomas","Hernandez","Moore","Martin","Jackson","Thompson","White","Lopez","Lee","Gonzalez","Harris","Clark","Lewis","Robinson","Walker","Perez","Hall","Young","Allen","Sanchez","Wright","King","Scott","Green","Baker","Adams","Nelson","Hill","Ramirez","Campbell","Mitchell","Roberts","Carter","Phillips","Evans","Turner","Torres","Parker","Collins","Edwards","Stewart","Flores","Morris","Nguyen","Murphy","Rivera","Cook","Rogers","Morgan","Peterson","Cooper","Reed","Bailey","Bell","Gomez","Kelly","Howard","Ward","Cox","Diaz","Richardson","Wood","Watson","Brooks","Bennett","Gray","James","Reyes","Cruz","Hughes","Price","Myers","Long","Foster","Sanders","Ross","Morales","Powell","Sullivan","Russell","Ortiz","Jenkins","Gutierrez","Perry","Butler","Barnes","Fisher","Henderson","Coleman","Simmons","Patterson","Jordan","Reynolds","Hamilton","Graham","Kim","Gonzales","Alexander","Ramos","Wallace","Griffin","West","Cole","Hayes","Chavez","Gibson","Bryant","Ellis","Stevens","Murray","Ford","Marshall","Owens","Mcdonald","Harrison","Ruiz","Kennedy","Wells","Alvarez","Woods","Mendoza","Castillo","Olson","Webb","Washington","Tucker","Freeman","Burns","Henry","Vasquez","Snyder","Simpson","Crawford","Jimenez","Porter","Mason","Shaw","Gordon","Wagner","Hunter","Romero","Hicks","Dixon","Hunt","Palmer","Robertson","Black","Holmes","Stone","Meyer","Boyd","Mills","Warren","Fox","Rose","Rice","Moreno","Schmidt","Patel","Ferguson","Nichols","Herrera","Medina","Ryan","Fernandez","Weaver","Daniels","Stephens","Gardner","Payne","Kelley","Dunn","Pierce","Arnold","Tran","Spencer","Peters","Hawkins","Grant","Hansen","Castro","Hoffman","Hart","Elliott","Cunningham","Knight","Bradley","Carroll","Hudson","Duncan","Armstrong","Berry","Andrews","Johnston","Ray","Lane","Riley","Carpenter","Perkins","Aguilar","Silva","Richards","Willis","Matthews","Chapman","Lawrence","Garza","Vargas","Watkins","Wheeler","Larson","Carlson","Harper","George","Greene","Burke","Guzman","Morrison","Munoz","Jacobs","Obrien","Lawson","Franklin","Lynch","Bishop","Carr","Salazar","Austin","Mendez","Gilbert","Jensen","Williamson","Montgomery","Harvey","Oliver","Howell","Dean","Hanson","Weber","Garrett","Sims","Burton","Fuller","Soto","Mccoy","Welch","Chen","Schultz","Walters","Reid","Fields","Walsh","Little","Fowler","Bowman","Davidson","May","Day","Schneider","Newman","Brewer","Lucas","Holland","Wong","Banks","Santos","Curtis","Pearson","Delgado","Valdez","Pena","Rios","Douglas","Sandoval","Barrett","Hopkins","Keller","Guerrero","Stanley","Bates","Alvarado","Beck","Ortega","Wade","Estrada","Contreras","Barnett","Caldwell","Santiago","Lambert","Powers","Chambers","Nunez","Craig","Leonard","Lowe","Rhodes","Byrd","Gregory","Shelton","Frazier","Becker","Maldonado","Fleming","Vega","Sutton","Cohen","Jennings","Parks","Mcdaniel","Watts","Barker","Norris","Vaughn","Vazquez","Holt","Schwartz","Steele","Benson","Neal","Dominguez","Horton","Terry","Wolfe","Hale","Lyons","Graves","Haynes","Miles","Park","Warner","Padilla","Bush","Thornton","Mccarthy","Mann","Zimmerman","Erickson","Fletcher","Mckinney","Page","Dawson","Joseph","Marquez","Reeves","Klein","Espinoza","Baldwin","Moran","Love","Robbins","Higgins","Ball","Cortez","Le","Griffith","Bowen","Sharp","Cummings","Ramsey","Hardy","Swanson","Barber","Acosta","Luna","Chandler","Blair","Daniel","Cross","Simon","Dennis","Oconnor","Quinn","Gross","Navarro","Moss","Fitzgerald","Doyle","Mclaughlin","Rojas","Rodgers","Stevenson","Singh","Yang","Figueroa","Harmon","Newton","Paul","Manning","Garner","Mcgee","Reese","Francis","Burgess","Adkins","Goodman","Curry","Brady","Christensen","Potter","Walton","Goodwin","Mullins","Molina","Webster","Fischer","Campos","Avila","Sherman","Todd","Chang","Blake","Malone","Wolf","Hodges","Juarez","Gill","Farmer","Hines","Gallagher","Duran","Hubbard","Cannon","Miranda","Wang","Saunders","Tate","Mack","Hammond","Carrillo","Townsend","Wise","Ingram","Barton","Mejia","Ayala","Schroeder","Hampton","Rowe","Parsons","Frank","Waters","Strickland","Osborne","Maxwell","Chan","Deleon","Norman","Harrington","Casey","Patton","Logan","Bowers","Mueller","Glover","Floyd","Hartman","Buchanan","Cobb","French","Kramer","Mccormick","Clarke","Tyler","Gibbs","Moody","Conner","Sparks","Mcguire","Leon","Bauer","Norton","Pope","Flynn","Hogan","Robles","Salinas","Yates","Lindsey","Lloyd","Marsh","Mcbride","Owen","Solis","Pham","Lang","Pratt","Lara","Brock","Ballard","Trujillo","Shaffer","Drake","Roman","Aguirre","Morton","Stokes","Lamb","Pacheco","Patrick","Cochran","Shepherd","Cain","Burnett","Hess","Li","Cervantes","Olsen","Briggs","Ochoa","Cabrera","Velasquez","Montoya","Roth","Meyers","Cardenas","Fuentes","Weiss","Hoover","Wilkins","Nicholson","Underwood","Short","Carson","Morrow","Colon","Holloway","Summers","Bryan","Petersen","Mckenzie","Serrano","Wilcox","Carey","Clayton","Poole","Calderon","Gallegos","Greer","Rivas","Guerra","Decker","Collier","Wall","Whitaker","Bass","Flowers","Davenport","Conley","Houston","Huff","Copeland","Hood","Monroe","Massey","Roberson","Combs","Franco","Larsen","Pittman","Randall","Skinner","Wilkinson","Kirby","Cameron","Bridges","Anthony","Richard","Kirk","Bruce","Singleton","Mathis","Bradford","Boone","Abbott","Charles","Allison","Sweeney","Atkinson","Horn","Jefferson","Rosales","York","Christian","Phelps","Farrell","Castaneda","Nash","Dickerson","Bond","Wyatt","Foley","Chase","Gates","Vincent","Mathews","Hodge","Garrison","Trevino","Villarreal","Heath","Dalton","Valencia","Callahan","Hensley","Atkins","Huffman","Roy","Boyer","Shields","Lin","Hancock","Grimes","Glenn","Cline","Delacruz","Camacho","Dillon","Parrish","Oneill","Melton","Booth","Kane","Berg","Harrell","Pitts","Savage","Wiggins","Brennan","Salas","Marks","Russo","Sawyer","Baxter","Golden","Hutchinson","Liu","Walter","Mcdowell","Wiley","Rich","Humphrey","Johns","Koch","Suarez","Hobbs","Beard","Gilmore","Ibarra","Keith","Macias","Khan","Andrade","Ware","Stephenson","Henson","Wilkerson","Dyer","Mcclure","Blackwell","Mercado","Tanner","Eaton","Clay","Barron","Beasley","Oneal","Preston","Small","Wu","Zamora","Macdonald","Vance","Snow","Mcclain","Stafford","Orozco","Barry","English","Shannon","Kline","Jacobson","Woodard","Huang","Kemp","Mosley","Prince","Merritt","Hurst","Villanueva","Roach","Nolan","Lam","Yoder","Mccullough","Lester","Santana","Valenzuela","Winters","Barrera","Leach","Orr","Berger","Mckee","Strong","Conway","Stein","Whitehead","Bullock","Escobar","Knox","Meadows","Solomon","Velez","Odonnell","Kerr","Stout","Blankenship","Browning","Kent","Lozano","Bartlett","Pruitt","Buck","Barr","Gaines","Durham","Gentry","Mcintyre","Sloan","Melendez","Rocha","Herman","Sexton","Moon","Hendricks","Rangel","Stark","Lowery","Hardin","Hull","Sellers","Ellison","Calhoun","Gillespie","Mora","Knapp","Mccall","Morse","Dorsey","Weeks","Nielsen","Livingston","Leblanc","Mclean","Bradshaw","Glass","Middleton","Buckley","Schaefer","Frost","Howe","House","Mcintosh","Ho","Pennington","Reilly","Hebert","Mcfarland","Hickman","Noble","Spears","Conrad","Arias","Galvan","Velazquez","Huynh","Frederick","Randolph","Cantu","Fitzpatrick","Mahoney","Peck","Villa","Michael","Donovan","Mcconnell","Walls","Boyle","Mayer","Zuniga","Giles","Pineda","Pace","Hurley","Mays","Mcmillan","Crosby","Ayers","Case","Bentley","Shepard","Everett","Pugh","David","Mcmahon","Dunlap","Bender","Hahn","Harding","Acevedo","Raymond","Blackburn","Duffy","Landry","Dougherty","Bautista","Shah","Potts","Arroyo","Valentine","Meza","Gould","Vaughan","Fry","Rush","Avery","Herring","Dodson","Clements","Sampson","Tapia","Bean","Lynn","Crane","Farley","Cisneros","Benton","Ashley","Mckay","Finley","Best","Blevins","Friedman","Moses","Sosa","Blanchard","Huber","Frye","Krueger","Bernard","Rosario","Rubio","Mullen","Benjamin","Haley","Chung","Moyer","Choi","Horne","Yu","Woodward","Ali","Nixon","Hayden","Rivers","Estes","Mccarty","Richmond","Stuart","Maynard","Brandt","Oconnell","Hanna","Sanford","Sheppard","Church","Burch","Levy","Rasmussen","Coffey","Ponce","Faulkner","Donaldson","Schmitt","Novak","Costa","Montes","Booker","Cordova","Waller","Arellano","Maddox","Mata","Bonilla","Stanton","Compton","Kaufman","Dudley","Mcpherson","Beltran","Dickson","Mccann","Villegas","Proctor","Hester","Cantrell","Daugherty","Cherry","Bray","Davila","Rowland","Levine","Madden","Spence","Good","Irwin","Werner","Krause","Petty","Whitney","Baird","Hooper","Pollard","Zavala","Jarvis","Holden","Haas","Hendrix","Mcgrath","Bird","Lucero","Terrell","Riggs","Joyce","Mercer","Rollins","Galloway","Duke","Odom","Andersen","Downs","Hatfield","Benitez","Archer","Huerta","Travis","Mcneil","Hinton","Zhang","Hays","Mayo","Fritz","Branch","Mooney","Ewing","Ritter","Esparza","Frey","Braun","Gay","Riddle","Haney","Kaiser","Holder","Chaney","Mcknight","Gamble","Vang","Cooley","Carney","Cowan","Forbes","Ferrell","Davies","Barajas","Shea","Osborn","Bright","Cuevas","Bolton","Murillo","Lutz","Duarte","Kidd","Key","Cooke"]};
  async function fetchData(url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      return response.json();
    } catch (error) {
      console.error('Unable to fetch data:', error);
    }
  }
  function fetchNames(nameType) {
    return fetchData(`https://www.randomlists.com/data/names-${nameType}.json`);
  }
  async function generateName(gender) {
    try {
      const response = await Promise.all([
        fetchNames(gender || pickRandom(['male', 'female'])),
        fetchNames('surnames')
      ]);
  
      const [firstNames, lastNames] = response;
  
      const firstName = pickRandom(firstNames.data);
      const lastName = pickRandom(lastNames.data);
  
      return `${firstName} ${lastName}`;
    } catch(error) {
      console.error('Unable to generate name:', error);
    }
  }
  const pickRandom = (list) => {
    return list[Math.floor(Math.random() * list.length)];
  }

  const pickSpadeElementName = (leafnodetype) => {
    try {
      const rand_name = () => pickRandom(randNames.data);

      const findClash = () => { return elements.find(e => isNode(e) && (leafnodetype === e.leafnodetype) )};

      if(findClash()) {
        throw 'LEAF Error: pickSpadeElementName(): only a single spade element instance can exist in a LEAD';
      }

      const name = rand_name();

      return name;
    }
    catch(err) {
      throw err;
    }
  };

  const pickRandomElementName = (leafnodetype) => {
    try {
      const rand_name = () => pickRandom(randNames.data);

      const findClash = (name) => { return elements.find(e => isNode(e) && (leafnodetype === e.leafnodetype) && (name === e.data.name) )};

      let name = rand_name();
      let trial_count = 0;
      const max_trial = 10

      while (findClash(name) && trial_count < max_trial ) {
        trial_count += 1;
        name = rand_name();
        console.debug("new name: ",name, trial_count);
      }

      if (trial_count === max_trial) {
        throw 'LEAF Error: pickRandomElementName() ran out of the random element name pool';
      }
      return name;
    }
    catch(err) {
      throw err;
    }
  };

  
  const onLoad = (_reactFlowInstance) => { 
    _reactFlowInstance.fitView();
    setReactFlowInstance(_reactFlowInstance);
    console.log('flow loaded:', _reactFlowInstance);
  }

  const onDragOver = (event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  };

  /*
  const onDrop = (event) => {
    event.preventDefault();

    const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
    const type = event.dataTransfer.getData('application/reactflow');
    const leaduuid = event.dataTransfer.getData('leaduuid');
    const datakey = event.dataTransfer.getData('datakey');
    const position = reactFlowInstance.project({
      x: event.clientX - reactFlowBounds.left,
      y: event.clientY - reactFlowBounds.top,
    });
    const newNode = {
      id: uuidv4(),
      type,
      position,
      data: { label: `${leaduuid} ${type} node`,
              leaduuid: `${leaduuid}`,
              datakey: `${datakey}`, 
            },

      style: { border: '1px solid #777', padding: 2, borderRadius: '5px' }
    };

    setElements((es) => es.concat(newNode));
  };
  */

  const onTextChange = (event) => { // : ChangeEvent
    setElements((els) =>
      els.map((e) => {
        if (isEdge(e) || e.id !== '2') {
          return e;
        }

        const color = event.target.value;

        setBgColor(color);

        console.debug("data: ", e.data);
        return {
          ...e,
          data: {
            ...e.data,
          },
        };
      })
    );
  };

  const onColorChange = (event) => { //: ChangeEvent
    setElements((els) =>
      els.map((e) => {
        if (isEdge(e) || e.id !== '2') {
          return e;
        }

        const color = event.target.value;

        setBgColor(color);

        console.log("data: ", e.data);
        return {
          ...e,
          data: {
            ...e.data,
            color,
          },
        };
      })
    );
  };

  const onDrop = async (event) => {
    event.preventDefault();

    const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
    const type = event.dataTransfer.getData('application/reactflow');
    const datakey = event.dataTransfer.getData('datakey');
    const leafnodetype = event.dataTransfer.getData('leafnodetype');
    const position = reactFlowInstance.project({
      x: event.clientX - reactFlowBounds.left,
      y: event.clientY - reactFlowBounds.top,
    });

    const node_uuid = uuidv4();
    //const leaduuid = event.dataTransfer.getData('leaduuid');
    // ignore the supplied leaduuid only used for testing, and assign it a real uuid 
    // spark dev note: 15/July/2021
    // The argument 'data.leaduuid' being passed here is used as nodeId needed by AnchorHandle or other LEAF custom Handles. 
    // In the stock Handle defined by react-flow-renderer library, nodeId is assigned by referring to the runtime context which is not exported, 
    // hence the argument passing
    const leaduuid = node_uuid;
    const data_obj = { //label: `${leaduuid} ${type} node`,
            leaduuid: `${leaduuid}`,
            //datakey: `${datakey}`, 
            //nodeid: node_uuid,
          };

    if (['leafdatafilternode', 'leafdatacombinenode'].includes(leafnodetype)) {
      //data_obj.onChange = onTextChange;  // deprecated
    }
    else if (['leafutilitynode'].includes(leafnodetype)) {
      data_obj.onChange = onColorChange; // deprecated
    }
    else if (['leafoperatornode'].includes(leafnodetype)) {
      const operatortype = event.dataTransfer.getData('operatortype');
      data_obj.operatortype = operatortype;
    }
    else if (['leafdeckheart', 'leafdeckdiamond', 'leafdeckclub'].includes(leafnodetype)) {
      const name = pickRandomElementName(leafnodetype);
      data_obj.name = name;
    }
    else if (['leafdeckspade'].includes(leafnodetype)) {
      const name = pickSpadeElementName(leafnodetype);
      data_obj.name = name;
    }

    const new_editor_node = {
      id: node_uuid,
      type,
      leafnodetype,
      position,
      data: data_obj,

      style: { border: '1px solid #777', padding: 2, borderRadius: '5px' }
    };

    //mutationRequests.current.push(getLEAFgqlStrAddNode(new_node));

    const node_data = { leafeditor: {
      //type: `${type}`,
      type: leafnodetype,
      position: position, 
      logictoggle: true, // boolean default
    }};
    //mutateNode({id: node_uuid, data: sjcl.codec.base64.fromBits(JSON.stringify(node_data))});
    // spark dev note: the 'label' field at the node's top field level is currently not being used by leafeditor
    // the principle of organizing node data fields is to put any leafeditor specific data under the 'data' field.
    //mutateAddNode({variables: {uuid: node_uuid, label: '', data: btoa(JSON.stringify(node_data))}});
    //await mutateAddNode({uuid: node_uuid, type: type, position: JSON.stringify(position)});
    await mutateAddNode({variables: {uuid: node_uuid, label: '', data: btoa(JSON.stringify(node_data))}});

    setElements((es) => es.concat(new_editor_node));
  };

  const onNodeDragStop = async (event, node) => { //(event: MouseEvent, node: Node)
    console.debug('floweditor/index.js: onNodeDragStop()', node);
    //const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
    //const new_position = reactFlowInstance.project({
    //  x: event.clientX - reactFlowBounds.left - event.offsetX,
    //  y: event.clientY - reactFlowBounds.top - event.offsetY,
    //});
    //new_position.x -= event.offsetX;
    //new_position.y -= event.offsetY;
    const node_data = { leafeditor: {
      //leaduuid: `${data.leaduuid}`,
      ...node.data,
      //type: "leafdatafilternode",
      //position: new_position, // screen position of the leafeditor node changed
      position: node.position, //new_position, // screen position of the leafeditor node changed
      //nodeid: node_uuid,
    }};
    //let json_data = JSON.stringify(node_data).getBytes("UTF-8");
    //let enc_data = sjcl.codec.base64.fromBits(json_data);
    //let dec_data = sjcl.codec.base64.toBits(enc_data);
    //let enc_data = Base64.stringify(json_data);

    // spark dev note: currently it's unclear whether the graphql updateNode mutation can support partial update,
    // that is updating only a portion of the data instead of updating the whole lot. 
    // In the current implementation, it was assumed that "partial update" isn't supported, 
    // hence the smallest unit update here is to replace the entire node data on each update 
    // even if it would only involve partial change in a single field. 
    //node.data.label?node.data.label:
    try {
      node.data.position = node.position; // update local memory to account for the server update delay
      //await mutateUpdateNode({variables: {uuid: node.data.leaduuid, label: '', data: btoa(JSON.stringify(node_data))}})
      console.debug('node.position', JSON.stringify(node.position));
      setElements(elements.map((el) => {return (el.id === node.id) ? {...node, data: {...node.data, position: node.position}} : el})); // update local copy prior to server update
      mutateUpdateNode({variables: {uuid: node.data.leaduuid, label: '', data: btoa(JSON.stringify(node_data))}})
      //.then(
      //  ({error}) => {
      //    console.log(error);
      //  }
      //);
    } catch (error) {
      console.error(error);
    }

  }
  //const onElementClick = (_: MouseEvent, element: FlowElement) => console.log('click', element);

  useEffect(() => {
    const edge_handle_dict = {
      'leaflambdaedge': {sourceHandle: 'out_aux', targetHandle: 'in_aux'},
      'leafanchoredge': {sourceHandle: 'out_anchor', targetHandle: 'in_anchor'},
      'leafdataedge': {sourceHandle: 'out_a', targetHandle: 'in_a'},
    }
    const edge_style_dict = {
      'leaflambdaedge': {stroke: '#fff', fillOpacity: 0,},
      'leafanchoredge': {stroke: '#88f', fillOpacity: 0,},
      'leafdataedge': {stroke: '#fff', fillOpacity: 0,},
    }

    const parseGraphNodesToEditorElements = (nodes) => {
      let el_list = [];
      nodes.map((n) => {
        if (n.data) {
        //let parsed_node_data = JSON.parse(sjcl.codec.base64.toBits(n.data));
          let parsed_node_data = JSON.parse(atob(n.data)); // base64 decode and convert json string to js object
          const a_node = {
            id: n.uuid, // a field required by react-flow-renderer, pls do not remove.
            type: parsed_node_data ? parsed_node_data.leafeditor.type : null,
            //leafnodetype,
            position: parsed_node_data ? parsed_node_data.leafeditor.position : null,
            data: { ...parsed_node_data.leafeditor, leaduuid: n.uuid}, //label: n.label, // 'data' here is a react-flow-renderer required field for proprietary data
            style: { border: '1px solid #777', padding: 2, borderRadius: '5px' },
          };

          el_list.push(a_node);
        }

        let edges = n.out_edges;

        edges.map((e) => {
          if (e.data) {
            let parsed_edge_data = JSON.parse(atob(e.data)); // base64 decode edge data from the leaf lake and convert its json string to js object
            const an_edge = {
              id: e.uuid,
              type: parsed_edge_data.leafeditor.type,
              //leafnodetype,
              //data: data_obj,
              source: e.source.uuid,
              target: e.target.uuid,
              ...edge_handle_dict[parsed_edge_data.leafeditor.type],
              style: edge_style_dict[parsed_edge_data.leafeditor.type],
              //style: {fillOpacity: 0 , },
              data: { ...parsed_edge_data.leafeditor },
            };

            el_list.push(an_edge);
          }
          return null;
        });

        return null;
      });

      return el_list;
    };

    const handleGraphUpdate = ({ data: { getGraph: {nodes, edges }}, errors }) => {
      if (errors && errors.length > 0) {
        console.log(errors[0])
      };
      if (nodes) {
        console.log('vertice list updated');
        //graph_data.nodes = nodes; // update vertices 
        //setGraphData({"nodes": nodes, "edges": graph_data.edges});
        let el_list = parseGraphNodesToEditorElements(nodes);
        if (el_list) {
          setElements(el_list);
          //setElements((es) => es.concat(el_list));
        }
      };
      if (edges) {
        console.log('edge list updated');
        console.log(edges);
        //graph_data.edges = edges; // update edges
        //setGraphData({"nodes": graph_data.nodes, "edges": edges});
      };
    };
    const subsCallback = (event) => {
      console.log(event);
      handleGraphUpdate(event);
    };
    const errorSubsCallback = (error) => {
      console.log('Error: ', error);
    };
    const gql_subs_client = createClient({
      endpoint: endpoint_subs,
      headers: {
        'Content-Type': 'application/json',
      },
      websocket: {
        endpoint: websocket_subs,
        onConnectionSuccess: () => {
          console.log('gql_subs_client: Connected')
          try {
            gql_subs_client.subscribe(
              {
                subscription: getLEAFgqlSubs('temporary_test_appid'),
                //onGraphQLData: (data) => { console.log('gql_subs_client: onGraphQLData()', data)},
                //onGraphQLError: (data) => { console.log('gql_subs_client: onGraphQLError()', data)},
                onGraphQLComplete: (data) => { console.log('gql_subs_client: onGraphQLComplete()', data)},
              },
              subsCallback,
              errorSubsCallback
            );
          } catch (error) {
            console.log('Error: ', error);
          }
        },
        onConnectionError: () => console.log('gql_subs_client: Connection Error'),
      }
    });

    const onFocusEventHandler = () => {
      console.log("window focus on");
      //console.log(gql_subs_client);
      // if client websocket is closing or closed
      // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState
      if ([WebSocket.CLOSED,WebSocket.CLOSING].includes(gql_subs_client.clientContext.websocket.client.readyState)) {
        console.log("WebSocket currently not open or opening. Re-establishing the connection...");
        gql_subs_client.establishWS();
      }
    }

    const onBlurEventHandler = () => {
      console.log("window focus off");
    }

    window.addEventListener("focus", onFocusEventHandler);
    window.addEventListener("blur", onBlurEventHandler);

    const nodeWidth = 172;
    const nodeHeight = 36;
    const getLayoutedElements = (elements, direction = 'TB') => {
      const isHorizontal = direction === 'LR';
      dagreGraph.setGraph({ rankdir: direction });

      elements.forEach((el) => {
        if (isNode(el)) {
          dagreGraph.setNode(el.id, { width: nodeWidth, height: nodeHeight });
        } else {
          dagreGraph.setEdge(el.source, el.target);
        }
      });

      dagre.layout(dagreGraph);

      return elements.map((el) => {
        if (isNode(el)) {
          const nodeWithPosition = dagreGraph.node(el.id);
          el.targetPosition = isHorizontal ? 'left' : 'top';
          el.sourcePosition = isHorizontal ? 'right' : 'bottom';

          // unfortunately we need this little hack to pass a slightly different position
          // to notify react flow about the change. Moreover we are shifting the dagre node position
          // (anchor=center center) to the top left so it matches the react flow node anchor point (top left).
          el.position = {
            x: nodeWithPosition.x - nodeWidth / 2 + Math.random() / 1000,
            y: nodeWithPosition.y - nodeHeight / 2,
          };
        }

        return el;
      });
    };

    return () => { // the following is a clean up code akin to componentWillUnmount()
      setElements([]);
      window.removeEventListener("focus", onFocusEventHandler);
      window.removeEventListener("blur", onBlurEventHandler)
    }
  }, []);
    /*
    setElements(getLayoutedElements([
      {
        id: 'bc1',
        type: 'leafdatafilternode',
        data: { onChange: onTextChange, leaduuid: 'bc1' },
        style: { border: '1px solid #777', padding: 2, borderRadius: '5px' },
        //position: { x: 250, y: 50 },
      },
      {
        id: '1',
        type: 'input',
        data: { label: 'An input node', leaduuid: '1' },
        //position: { x: 0, y: 50 },
        sourcePosition: Position.Right,
      },
      {
        id: '2',
        type: 'leafutilitynode',
        data: { onChange: onColorChange, color: initBgColor, leaduuid: '2' },
        style: { border: '1px solid #777', padding: 2, borderRadius: '5px' },
        //position: { x: 250, y: 50 },
      },
      {
        id: '3',
        type: 'output',
        data: { label: 'Output A', leaduuid: '3' },
        //position: { x: 550, y: 25 },
        targetPosition: Position.Left,
      },
      {
        id: '4',
        type: 'output',
        data: { label: 'Output B', leaduuid: '4' },
        //position: { x: 550, y: 100 },
        targetPosition: Position.Left,
      },
      {
        id: 'bc2',
        type: 'leafdatafilternode',
        leafnodetype: 'leafdatafilternode',
        data: { onChange: onTextChange, leaduuid: 'bc2' },
        style: { border: '1px solid #777', padding: 2, borderRadius: '5px' },
        //position: { x: 250, y: 50 },
      },
      {
        id: 'bc3',
        type: 'leafdatafilternode',
        data: { onChange: onTextChange, leaduuid: 'bc3' },
        style: { border: '1px solid #777', padding: 2, borderRadius: '5px' },
        //position: { x: 250, y: 50 },
      },
      { id: 'bc_e3', source: 'bc1', target: '2', sourceHandle: 'out_aux', targetHandle: 'in_aux', type: 'leaflambdaedge', animated: false, style: {stroke: '#8ff', fillOpacity: 0 , }, data: { text: 'e1-2' } },
      { id: 'bc_e2', source: 'bc1', target: 'bc3', sourceHandle: 'out_a', targetHandle: 'in_a', type: 'leafdataedge', animated: false, style: {stroke: '#8ff', fillOpacity: 0 , }, data: { text: 'e1-2' } },
      { id: 'bc_e1', source: 'bc1', target: 'bc2', sourceHandle: 'out_anchor', targetHandle: 'in_anchor', type: 'leafanchoredge', animated: false, style: {stroke: '#8ff', fillOpacity: 0 , }, data: { text: 'e1-2' } },
      { id: 'e1-2', source: '1', target: '2', targetHandle: 'in_a', type: 'leafdataedge', animated: false, style: {stroke: '#fff', fillOpacity: 0 , }, data: { text: 'e1-2' } },
      { id: 'e2a-3', source: '2', type: 'leafdataedge', sourceHandle: 'out_a', target: '3', animated: false, style: { stroke: '#fff', fillOpacity: 0 }, data: { text: '' } },
      { id: 'e2b-4', source: '2', type: 'leafdataedge', sourceHandle: 'out_a', target: '4', animated: true, style: { stroke: '#fff', fillOpacity: 0 }, data: { text: '' } },
    ], 'LR'));
    */

  const onElementsRemove = async (elementsToRemove) => {
//      mutateUpdateNode({variables: {uuid: node.data.leaduuid, label: '', data: btoa(JSON.stringify(node_data))}}).then(
    elementsToRemove.map(async (el) => {
      if ('source' in el) {
        mutateDelEdge({edge_uuid: el.id});
      }
      else {
        mutateDelNode({node_uuid: el.id});
      }
    });
    setElements((els) => removeElements(elementsToRemove, els));
  };

  const onConnect = async (params) => { //(params: Connection | Edge)
    if (params.source !== params.target) {
      if (params.sourceHandle === 'out_aux' && params.targetHandle === 'in_aux') {
        //const targetlambda = elements.filter(el => el.targetHandle === 'in_aux' && el.target === params.target) 
        const edgetype = 'leaflambdaedge';
        const existingedge = elements.filter(el => el.type === edgetype && el.source === params.source && el.target === params.target);
        if (!existingedge[0]) { // this check would limit the number of leaflmabdaedge type edges between the source and the target to 1
          const edge_uuid = uuidv4();
          const edge_data = { leafeditor: {
            //type: `${type}`,
            type: edgetype,
          }};
          await mutateAddEdge({variables: {uuid: edge_uuid, label: '', sourceuuid: params.source, targetuuid: params.target, data: btoa(JSON.stringify(edge_data))}});
          setElements((els) => addEdge({ ...params, type: edgetype, animated: false, style: { stroke: '#fff', fillOpacity: 0 }, data: { text: '' } }, els));
        }
      }
      else if (params.sourceHandle === 'out_anchor' && params.targetHandle === 'in_anchor') {
        const edgetype = 'leafanchoredge';
        const targetanchor = elements.filter(el => el.targetHandle === 'in_anchor' && el.target === params.target) 
        if (!targetanchor[0]) { // this check would limit the number of in-bound connections into in_anchor to 1
          const edge_uuid = uuidv4();
          const edge_data = { leafeditor: {
            //type: `${type}`,
            type: edgetype,
          }};
          await mutateAddEdge({variables: {uuid: edge_uuid, label: '', sourceuuid: params.source, targetuuid: params.target, data: btoa(JSON.stringify(edge_data))}});
          setElements((els) => addEdge({ ...params, type: edgetype, animated: false, style: { stroke: '#88f', fillOpacity: 0 }, data: { text: '' } }, els));
        }
      }
      else if ((params.sourceHandle !== 'out_aux' && params.targetHandle !== 'in_aux') && 
      (params.sourceHandle !== 'out_anchor' && params.targetHandle !== 'in_anchor')) {
        const edgetype = 'leafdataedge';
        const edge_uuid = uuidv4();
        const edge_data = { leafeditor: {
          //type: `${type}`,
          type: edgetype,
        }};
        await mutateAddEdge({variables: {uuid: edge_uuid, label: '', sourceuuid: params.source, targetuuid: params.target, data: btoa(JSON.stringify(edge_data))}});
        setElements((els) => addEdge({ ...params, type: edgetype, animated: false, style: { stroke: '#fff', fillOpacity: 0 }, data: { text: '' } }, els));
      }

    }
    else {
      console.log("no self loop allowed")
    }
  }

  /*
      <MiniMap
        nodeStrokeColor={(n: Node): string => {
          if (n.type === 'input') return '#0041d0';
          if (n.type === 'leafnode') return bgColor;
          if (n.type === 'output') return '#ff0072';

          return '#eee';
        }}
        nodeColor={(n: Node): string => {
          if (n.type === 'leafnode') return bgColor;
          if (n.type === 'leafdatafilternode') return '#33f3f0'; // this color determines the minimap appearance
          if (n.type === 'leafdatacombinenode') return '#003fff'; // ditto

          return '#fff';
        }}
      />
  */
  // spark_dev_note: the current behavior of leaf_editor client getting re-connected to LEAF graphql server
  // ensures that up-to-date leaf logic is displayed across multiple client interfaces in the event of 
  // disconnections due to various reasons. 
  // The current implementation relies on window-level onFocus event to triage the need to re-establish the websocket
  // and the graphql subscription needed. This means that the displayed leaf logic might still become stale 
  // if the editor window is left without losing focus. 
  // The JSX return in the following can be modified to have conditional rendering
  // dependent upon the WS connection status, in order to prevent that route of leaf logic going stale. 
  return (
    <div className="reactflow-wrapper" ref={reactFlowWrapper} style={{height:700, zIndex:0}} >
    <ReactFlow
      elements={elements}
      elementsSelectable={isSelectable}
      //nodesConnectable={isConnectable}
      //onElementClick={onElementClick}
      onElementsRemove={onElementsRemove}
      onConnect={onConnect}
      onNodeDragStop={onNodeDragStop}
      style={{ background: bgColor }}
      onLoad={onLoad}
      onDrop={onDrop}
      onDragOver={onDragOver}
      nodeTypes={nodeTypes}
      edgeTypes={edgeTypes}
      connectionLineStyle={connectionLineStyle}
      snapToGrid={true}
      snapGrid={snapGrid}
      defaultZoom={1.5}
    >
      <Controls />
    </ReactFlow>
    <LEAFSidebar />
    </div>
  );
};

export function LEAFEditor(props) {
  return (
    <ClientContext.Provider value={GRAPHQL_CLIENT}>
      <ReactFlowProvider>
        <LEAFEditorCore />
      </ReactFlowProvider>
    </ClientContext.Provider>
  );
}

export default LEAFEditor;
